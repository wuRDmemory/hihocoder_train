# 最长回文子字符串

## 基本思路
1. 暴力搜索方法
> a. 将输入的字符串翻转 
> b. 遍历原始字符串的i～j之间的字符串能否在翻转的字符串中找到


2. manacher算法
基本思想：
算法主要依赖对称的思想解决问题，例如对于字符串中下标为id的位置，他的回文半径为p\[id\],那么对于下标为i(i>id)的位置，他的回文半径必然是大于等于下标为id-(i-id)的回文半径，主要就是因为对称！这样节约了很多时间
需要注意的一点是，由于算法采用的是对称的思想，因此整个字符串的长度必须是奇数，所以会在原本的字符串没两个字符之间插入#，同时为了解决越界问题，在两个边界的地方加入$@字符进行区别
参考博客：[here](https://blog.csdn.net/sinat_30071459/article/details/51044331)
伪码：
```objectivec
id = 1
p[1] = 1 // p[0]是左边界，这里不对它进行迭代，所以就不处理了
for i=1:N-1
    // id的回文范围包括了i
    if p[id]+id-1 > i 
        // 因为p[id-(i-id)]的左边回文范围可能超出p[id]的范围，但是i处并不适用，因此必须限制
        p[i] = min(p[id-(i-id)], p[id]+id-1) 
    else
        // p[i]的初始回文半径
        p[i] = 1
    
    // 重新确定i的回文范围
    while s[i-p[i]] == s[i+p[i]]
        p[i]++;
        
    // 保证id的范围是最接近右边的，从左到右遍历嘛
    if p[id]+id<p[i]+i
        id = i
    
    if max_LPS < p[id]
        max_LPS = p[id]
```