# KMP算法
针对一个字符串，给出模式字符串，从字符串中找出有多少个模式字符串
字符串：ADADA
模式：ADA
匹配次数为2次 

## 基本思想
1. 暴力方法
遍历整个字符串，与模式字符串进行比较，成功则将次数加1
缺点：十分慢，主要是因为不管是成功还是不成功的匹配，都要将指针溯源到匹配点的下一个字符

2. KMP方法
针对上面的方法，KMP的思想就是每次可以不溯源回去，而是匹配失败了就将最近的匹配点与下一个字符进行匹配
例如： 字符串：AAADACD  模式：    AAC
当AAA与AAC匹配失败了之后，程序能自动将AAA的第三个A与AAC中的第二个A进行对比，而不用回溯到第二个A与第一个A的对比上
完成上述功能的主要功臣是一个next数组，这个数组的产生是关键，主要介绍该数组的产生
> 基本思想：
> 0. next[i]就是如果i-1位置的模式字符(注意遍历字符的时候下标是从0开始的)匹配失败了，模式字符需要回到的那个位置(即上面例子中的那个位置)，所以next数组是为了下一个字符匹配失败而设计的
> 1. next[0] = -1，这类似于一个缺省值，就是当回溯到0的时候，认为当前字符串的字符与模式的第一个字符并不相等，给-1让程序向下一步移动
> 2. 让模式字符自回溯，如果当前的字符与回溯到的字符是相等的，也就是当前的模式字符在模式中是有重复的，那么下一个字符失败的时候，要回溯的位置就是当前回溯位置的下一位
> 3. 如果当前字符与回溯到的字符是不相等的，那么就继续回溯，一直到回溯到-1为止。
> eg：例如上面的AAC
> a. 对于第一个A而言，匹配失败了，则要回溯到0，因此有next[1]=0
> b. 对于第二个A而言，它能回溯位置的字符刚好一致，因此如果它匹配失败了，就回溯到回溯位置的下一个字符与当前的字符进行对比

伪码：
```
int i=0, j=-1   // 这里i表示当前匹配的位置，j表示回溯到的位置
while i<P_len
	if  j==-1 or P[i]==P[j]
		// 当回溯到的位置为-1时，说明当前字符匹配失败的时候，要从模式串的最开始回溯(匹配)了
		// 当当前字符匹配失败了，那么我们就看一下回溯到的位置(j)的字符是否与当前字符一致，一致的话说明下一个字符匹配失败了的话，那么它的回溯位置就是当前回溯的位置的下一位，否则的话我们就对当前的回溯位置再次进行回溯
		next[++i] = ++j
	else
		// 当当前字符匹配失败的时候，就回溯到上一次字符给准备的回溯点去
		j = next[j]
```
所以可以看到，在整个next数组的产生过程中，都是第i位在为第i+1位规划，也就是第i位告诉第i+1位说：如果你匹配失败了，就去找第j位